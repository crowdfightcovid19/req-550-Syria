# ****************************************
# model_output_summaries.R
# ****************************************
# 
# 
# author = Alberto Pascual-GarcÃ­a 
# email = alberto.pascual.garcia@gmail.com 
# date = 15th July 2020
# description = This takes a set of directories generated by the stochastic version of 
#    SEPAIHRD-Syria_structured.R, and creates a single table computing means and standard errors
#    for some variables of interest, specified by the user. For some variables (e.g. time to
#    steady state) these means are computed differentiating shielded and exposed population. It
#    is also estimated the probability of observing an outbreak (i.e. at least one death, a more strict
#    criteria could be used but should be recoded) and the Case fatality ratio.
# usage = Determine the files that you want to process and add, for each file, a code to determine
#   if you want to retrieve relative numbers files.codes="Frac", total numbers ="Num" or means
#   across the different  simulations ="Time". The latter case should be used to estimate the times
#   in which, e.g. a peak of infection, occur.
#   In addition, the file NumFinalDeaths and NumFinalRecovered must always be processed, because are
#   used to narrow the statisticsd down to simulations in which at least one death is observed, and to compute
#   the CFR. The file NumFinalDeaths must be located before NumFinalRecovered.
# note = The files.code could be avoided having a look at the name of the file, if it contains Num, we
#   typically want to compute fractions, if it contains Frac, we must sum values, and if it contains Time
#   we compute means per line. There are some greps implemented and commented, just substitute the
#   conditions to use the functions by e.g. !is_empty(fileF) do --> function_total
# note = Plots can be generated with model_output_summaries_plotMaster.R
rm(list=ls())

library(tidyverse)
library(ggplot2)
library(stringi)
library(stringr)


#### START EDITING

keywordS="green" # a keyword to identify (S)hielded pop
keywordE="orange" # non-shielded pop (E)xposed 

# .... Enumerate the header of the files you want to process
files.list=c("NumFinalDeaths","NumFinalRecovered","TimePeakSymptomatic")#,"TimeSteadyStateSusceptible")
files.code=c("Frac","Frac","Time")#,"Time") # A vector determining which kind of statistics you want to
       # retrieve for each file (should have the same order than file.list). See header of script for details

# .... Directories to process
idDir="modSV" # this is a string contained in all the directories that should be processed

# .... Output file:
fileOut=paste("Summary_interventions_",idDir,".csv",sep="")
#### STOP EDITING

header.names=c("contacts","Isolate","Limit","Onset","Fate","Tcheck","PopSize","lock","self","mod")
Nparam=length(header.names)
# --- Source Functions 
# ..... Function to get output directories
get_output_directories <- function(directory) {
  list.dirs(directory) %>% 
    .[grepl(idDir, .) & !grepl("figures", .)]
}

# ..... Function to compute mean and stdErr of a given dataframe
get_statistics_frac_total <- function(df,PopSize,Nrealiz,idx){
  if(!is_empty(idx)){
    df.total=rowSums(df)/PopSize # fractions
    Mean=mean(df.total) # Mean total deaths
    stdErr=sd(df.total)/sqrt(Nrealiz) # Standard error
    Mean=signif(Mean,digits=2)
    stdErr=signif(stdErr,digits=2)
  }else{
    Mean=NA
    stdErr=NA
  }
  return(as.list(c(Mean,stdErr)))
}
get_statistics_total <- function(df,Nrealiz,idx){
  if(!is_empty(idx)){
    df.total=rowSums(df) # raw numbers
    Mean=mean(df.total) # Mean total deaths
    stdErr=sd(df.total)/sqrt(Nrealiz) # Standard error
    Mean=signif(Mean,digits=2)
    stdErr=signif(stdErr,digits=2)
  }else{
    Mean=NA
    stdErr=NA
  }
  return(as.list(c(Mean,stdErr)))
}
get_statistics_peaks <- function(df,Nrealiz,idx){
  #browser()
  if(!is_empty(idx)){
    df.total=rowMeans(df) # raw numbers, divide by PopSize to take fractions
    Mean=mean(df.total) # Mean total deaths
    stdErr=sd(df.total)/sqrt(Nrealiz) # Standard error
    Mean=signif(Mean,digits=2)
    stdErr=signif(stdErr,digits=2)
  }else{
    Mean=NA
    stdErr=NA
  }
  return(as.list(c(Mean,stdErr)))
}

# --- Create a header for the output
i=0
for(file2proc in files.list){
  i=i+1
  col1=paste(file2proc,"mean",sep=".")
  col2=paste(file2proc,"stderr",sep=".")
  col3=paste(file2proc,"mean.E",sep=".")
  col4=paste(file2proc,"stderr.E",sep=".")
  col5=paste(file2proc,"mean.S",sep=".")
  col6=paste(file2proc,"stderr.S",sep=".")
  header.names=c(header.names,col1,col2,col3,col4,col5,col6)
  if(file2proc=="NumFinalDeaths"){
    col7="P.outbrk.E"
    col8="P.outbrk.S"
    header.names=c(header.names,col7,col8)
  }else if(file2proc=="NumFinalRecovered"){
    col7="CFR.E"
    col8="CFR.S"
    header.names=c(header.names,col7,col8)
  }
}

# --- Move to directory and retrieve list of directories
this.dir=strsplit(rstudioapi::getActiveDocumentContext()$path, "/src/")[[1]][1] 
dirCode=paste(this.dir,"/src",sep="")
dirData=paste(this.dir,"/data/real_models/",sep="")
dirOut=paste(dirData,"results_post_processing",sep="")
dirPlotOut=paste(dirOut,"/Summary_figures",sep="")
setwd(dirData)
subLabel="_SEPAIHRD_dynamics"
dir.list=get_output_directories(".")

# --- Start processing
#df.output=data.frame(stringsAsFactors = FALSE)
Nhead=length(header.names)
Nvals=Nhead-Nparam
df.output=matrix(NA,nrow=length(dir.list),ncol=Nhead)
df.output.char=matrix(NA,nrow=length(dir.list),ncol=Nparam)
df.output.vals=matrix(NA,nrow=length(dir.list),ncol=Nvals)

k=0
Nitems=30 # number of expected items in a directory if the simulation finished correctly
for(dirIn in dir.list){
  k=k+1
  cat(">> Processing directory: ",dirIn,"\n")
  # ... Control that the directory has finished the simulations
  contents=list.files(path = dirIn)
  if(length(contents) < 30){
    warning(paste("Skipping directory, it contains less than ",Nitems," items: ",dirIn)) 
    next
  } 
  # ... Extract population size and create some labels
  str.PopSize=stri_split_fixed(dirIn,"PopSize")[[1]][2] # Identify ppopulation size from dir name step 1
  PopSize=as.numeric(unlist(stri_split_fixed(str.PopSize,"_")[[1]][1])) # step2
  setwd(dirIn)
  fileLabel=gsub("/","_",dirIn) # Retrieve the label that all files have, related to the directory
  fileLabel=gsub("^\\.","",fileLabel) # but some processing needed
  
  # ... Identify if the intervention involves setting up isolation tents (isoThr>0)
  files.list.local=files.list # From now we will use different names depending on the scenario
  isoThr.key=grep("Limit0",fileLabel) # If this search is non-empty 
  if(is_empty(isoThr.key)){ # It means the intervention is active
    file.class=apply(as.matrix(unlist(files.list)),MARGIN = 1,   # Symptomatic files change their name
                     FUN=function(x){!is_empty(grep("Symptomatic",x))}) # identify these files
    file.idx=which(file.class==TRUE) # only for the positions with these files
    files.list.local[file.idx]=lapply(files.list.local[file.idx], # apply the change in the names
                            FUN=function(x){str_replace(x,"Symptomatic","Symp_Iso-stage")})
  }
  
  # ... Extract all the parameters from directory description
  shieldLab=stri_split_fixed(fileLabel,"Isolate")[[1]][1] # retrieve the label identifying the contacts matrix
  shieldLab=gsub("^_","",shieldLab) # remove starting and final "_"
  shieldLab=gsub("_$","",shieldLab)
  otherLab=stri_split_fixed(fileLabel,shieldLab)[[1]][2]
  otherLab=gsub("^_","",otherLab)
  otherLabList=unlist(stri_split_fixed(otherLab,"_"))
  outputParam=c(shieldLab,otherLabList)
  outputLine=c()
  
  # ... Process Files
  i=0
  for(file2proc in files.list.local){
    cat("... Processing file: ", file2proc)
    i = i + 1
    fileIn = paste(file2proc, subLabel, fileLabel, ".dat", sep = "")
    # fileF = grep("^Frac", fileIn) # identify the type of file to select the statistics
    # fileN = grep("^Num", fileIn) # not used, we would compute fractions for Num files
    # fileT = grep("^Time", fileIn) # and totals for Frac files would be wrong
    df.all = read_csv(file = fileIn)
    df.all = subset(df.all, select = -c(X1))
    Nrealiz.all=dim(df.all)[1] # store the original number of realizations
    idx.classS = grep(keywordS, colnames(df.all)) # cols for shielded population
    idx.classE = grep(keywordE, colnames(df.all)) # remaining pop
    if (file2proc == "NumFinalDeaths") {
      # this file should be the first
      death.totals = rowSums(df.all) # because we will identify simulations with no deaths
      nodeath.obs = which(death.totals > 0) # and create an index to work only with them
      death.totals.E=rowSums(df.all[,idx.classE])
      nodeath.obs.E = which(death.totals.E > 0)
      death.totals.S=rowSums(df.all[,idx.classS])
      nodeath.obs.S = which(death.totals.S > 0)
    }
    df = df.all[nodeath.obs, ] # gather statistics only for cases where deaths are observed
    Nrealiz=dim(df)[1] # Number realizations for all set
    df.E = df.all[nodeath.obs.E, idx.classE] # only exposed
    df.S = df.all[nodeath.obs.S, idx.classS] # only susceptible
    Nrealiz.E = dim(df.E)[1] # this will reduce the number of realizations to those with no deaths
    Nrealiz.S = dim(df.S)[1] # this will reduce the number of realizations to those with no deaths
    if(files.code[i] == "Frac"){
      # files for which we want to gather fractions
      stat.list = get_statistics_frac_total(df, PopSize, Nrealiz, 1)
      stat.list.E = get_statistics_frac_total(df.E, PopSize, Nrealiz.E, idx.classE)
      stat.list.S = get_statistics_frac_total(df.S, PopSize, Nrealiz.S, idx.classS)
    } else if(files.code[i] == "Num"){
      # we want total numbers
      stat.list = get_statistics_total(df, Nrealiz, 1)
      stat.list.E = get_statistics_total(df.E, Nrealiz.E, idx.classE)
      stat.list.S = get_statistics_total(df.S, Nrealiz.S, idx.classS)
    } else if(files.code[i] == "Time"){
      # we want mean peak times
      stat.list = get_statistics_peaks(df, Nrealiz, 1)
      stat.list.E = get_statistics_peaks(df.E, Nrealiz.E, idx.classE)
      stat.list.S = get_statistics_peaks(df.S, Nrealiz.S, idx.classS)
    }
    df.mean = stat.list[[1]]
    df.stdErr = stat.list[[2]]
    if(is_empty(idx.classE)){
      df.mean.E = df.mean
      df.stdErr.E = df.stdErr
    }else{
      df.mean.E = stat.list.E[[1]]
      df.stdErr.E = stat.list.E[[2]]
    }
    df.mean.S = stat.list.S[[1]]
    df.stdErr.S = stat.list.S[[2]]
    
    outputLine = c(outputLine, df.mean, df.stdErr)
    outputLine = c(outputLine, df.mean.E, df.stdErr.E, df.mean.S, df.stdErr.S)
    
    if (file2proc == "NumFinalDeaths") {
      # take the death totals to compute CFR
      death.totals.all = mean(rowSums(df)) 
      death.totals.E = mean(rowSums(df.E)) 
      death.totals.S = mean(rowSums(df.S)) 
      # in addition, we estimate the probability of outbreak
      frac.nodeath = apply(df.all, 2, function(x) {
        length(which(x == 0))})/Nrealiz.all
      if (is_empty(idx.classS)) {
        # there is no shielding
        p.outbrk.E = signif(1 - min(frac.nodeath), digits = 2)
        p.outbrk.S = NA
      } else{
        p.outbrk.E = signif(1 - min(frac.nodeath[idx.classE]), digits = 2)
        p.outbrk.S = signif(1 - min(frac.nodeath[idx.classS]), digits = 2)
      }
      outputLine = c(outputLine, p.outbrk.E, p.outbrk.S)
    }else if (file2proc == "NumFinalRecovered") {
      recov.totals.all = mean(rowSums(df)) 
      recov.totals.E = mean(rowSums(df.E)) 
      recov.totals.S = mean(rowSums(df.S)) 
      CFR.all=signif(death.totals.all/(death.totals.all+recov.totals.all),digits=2)
      if (is_empty(idx.classS)){
        CFR.E=CFR.all
        CFR.S=NA
      }else{
        CFR.E=signif(death.totals.E/(death.totals.E+recov.totals.E),digits=2)
        CFR.S=signif(death.totals.S/(death.totals.E+recov.totals.S),digits=2)
      }
      
      outputLine = c(outputLine,CFR.E,CFR.S)
    }
  }
  df.output.char[k,]=outputParam
  df.output.vals[k,]=outputLine
  # N1=length(outputParam)
  # N2=length(outputLine)
  # df.tmp=as.data.frame(cbind(outputParam,outputLine))
  # df.output.char[k, 1:N1] = as.data.frame(outputParam)
  # df.output[k, (N1+1):(N1+N2)] = as.data.frame(outputLine)
  setwd(dirData)
}

mode(df.output.vals)="numeric"
df.output.vals=as.data.frame(df.output.vals)
df.output.fact=as.data.frame(unclass(df.output.char))
df.output=data.frame(df.output.fact,df.output.vals)

# --- Write output
colnames(df.output)=header.names

setwd(dirOut)
write.table(df.output,file=fileOut,quote=FALSE,sep=",",row.names = FALSE)

# Plots ----------
# Plots are prepared in external files, and each of them reads from an input
# file determining the interventions to be processed simultaneoulsy.

# See model_output_summaries_plotMaster.R to create plots

# setwd(dirCode)
# source("extract_subtable_output_summaries.R")
# source("model_output_summaries_plotA.R")
# setwd(dirCode)
# source("model_output_summaries_plotB.R")
# setwd(dirCode)
# source("model_output_summaries_plotG.R")
# setwd(dirCode)
# source("model_output_summaries_plotH.R")
# setwd(dirCode)
# source("model_output_summaries_plotK.R")



