# ****************************************
# model_output_summaries.R
# ****************************************
# 
# 
# author = Alberto Pascual-GarcÃ­a 
# email = alberto.pascual.garcia@gmail.com 
# date = 15th July 2020
# description = This takes a set of directories generated by the stochastic version of 
#    SEPAIHRD-Syria_structured.R, and creates a single table computing means and standard errors
#    for some variables of interest, specified by the user. For some variables (e.g. time to
#    steady state) these means are computed differentiating shielded and exposed population. It
#    is also estimated the probability of observing an outbreak (i.e. at least one death) and the Case
#    fatality ratio.
# usage = Determine the files that you want to process and add, for each file, a code to determine
#   if you want to retrieve relative numbers files.codes="Frac", total numbers ="Num" or means
#   across the different  simulations ="Time". The latter case should be used to estimate the times
#   in which, e.g. a peak of infection, occur.
#   In addition, the file NumFinalDeaths and NumFinalRecovered must always be processed, because are
#   used to narrow the statistics to simulations in which at least one death is observed, and to compute
#   the CFR. The file NumFinalDeaths must be located before NumFinalRecovered.
# note = The files.code could be avoided having a look at the name of the file, if it contains Num, we
#   typically want to compute fractions, if it contains Frac, we must sum values, and if it contains Time
#   we compute means per line. There are some greps implemented and commented, just substitute the
#   conditions to use the functions by e.g. !is_empty(fileF) do --> function_total
rm(list=ls())

library(tidyverse)
library(ggplot2)
library(stringi)


#### START EDITING

keywordS="green" # a keyword to identify (S)hielded pop
keywordE="orange" # non-shielded pop (E)xposed 

# .... Enumerate the header of the files you want to process
files.list=c("NumFinalDeaths","NumFinalRecovered","TimePeakInfected")#,"TimeSteadyStateSusceptible")
files.code=c("Frac","Frac","Time")#,"Time") # A vector determining which kind of statistics you want to
       # retrieve for each file (should have the same order than file.list). See header of script for details

# .... Directories to process
idDir="modSV" # this is a string contained in all the directories that should be processed

# .... Output file:
fileOut=paste("Summary_interventions_",idDir,".csv",sep="")
#### STOP EDITING

header.names=c("contacts","Isolate","Limit","Fate","Tcheck","PopSize","lock","self","mod")
# --- Source Functions 
# ..... Function to get output directories
get_output_directories <- function(directory) {
  list.dirs(directory) %>% 
    .[grepl(idDir, .) & !grepl("figures", .)]
}

# ..... Function to compute mean and stdErr of a given dataframe
get_statistics_frac_total <- function(df,PopSize,Nrealiz,idx){
  if(!is_empty(idx)){
    df.total=rowSums(df)/PopSize # fractions
    Mean=mean(df.total) # Mean total deaths
    stdErr=sd(df.total)/sqrt(Nrealiz) # Standard error
    Mean=signif(Mean,digits=2)
    stdErr=signif(stdErr,digits=2)
  }else{
    Mean=NA
    stdErr=NA
  }
  return(as.list(c(Mean,stdErr)))
}
get_statistics_total <- function(df,Nrealiz,idx){
  if(!is_empty(idx)){
    df.total=rowSums(df) # raw numbers
    Mean=mean(df.total) # Mean total deaths
    stdErr=sd(df.total)/sqrt(Nrealiz) # Standard error
    Mean=signif(Mean,digits=2)
    stdErr=signif(stdErr,digits=2)
  }else{
    Mean=NA
    stdErr=NA
  }
  return(as.list(c(Mean,stdErr)))
}
get_statistics_peaks <- function(df,Nrealiz,idx){
  if(!is_empty(idx)){
    df.total=rowMeans(df) # raw numbers, divide by PopSize to take fractions
    Mean=mean(df.total) # Mean total deaths
    stdErr=sd(df.total)/sqrt(Nrealiz) # Standard error
    Mean=signif(Mean,digits=2)
    stdErr=signif(stdErr,digits=2)
  }else{
    Mean=NA
    stdErr=NA
  }
  return(as.list(c(Mean,stdErr)))
}

# --- Create a header for the output
i=0
for(file2proc in files.list){
  i=i+1
  col1=paste(file2proc,"mean",sep=".")
  col2=paste(file2proc,"stderr",sep=".")
  col3=paste(file2proc,"mean.E",sep=".")
  col4=paste(file2proc,"stderr.E",sep=".")
  col5=paste(file2proc,"mean.S",sep=".")
  col6=paste(file2proc,"stderr.S",sep=".")
  header.names=c(header.names,col1,col2,col3,col4,col5,col6)
  if(file2proc=="NumFinalDeaths"){
    col7="P.outbrk.E"
    col8="P.outbrk.S"
    header.names=c(header.names,col7,col8)
  }else if(file2proc=="NumFinalRecovered"){
    col7="CFR.E"
    col8="CFR.S"
    header.names=c(header.names,col7,col8)
  }
}

# --- Move to directory and retrieve list of directories
this.dir=strsplit(rstudioapi::getActiveDocumentContext()$path, "/src/")[[1]][1] 
dirData=paste(this.dir,"/data/real_models/",sep="")
dirOut=paste(dirData,"results_post_processing",sep="")
setwd(dirData)
subLabel="_SEPAIHRD_dynamics"
dir.list=get_output_directories(".")

# --- Start processing
df.output=data.frame(stringsAsFactors = FALSE)
df.output=matrix(NA,nrow=length(dir.list),ncol=length(header.names))
k=0
for(dirIn in dir.list){
  k=k+1
  cat(">> Processing directory: ",dirIn,"\n")
  
  # ... Extract population size and create some labels
  str.PopSize=stri_split_fixed(dirIn,"PopSize")[[1]][2] # Identify ppopulation size from dir name step 1
  PopSize=as.numeric(unlist(stri_split_fixed(str.PopSize,"_")[[1]][1])) # step2
  setwd(dirIn)
  fileLabel=gsub("/","_",dirIn) # Retrieve the label that all files have, related to the directory
  fileLabel=gsub("^\\.","",fileLabel) # but some processing needed
  
  # ... Extract all the parameters from directory description
  shieldLab=stri_split_fixed(fileLabel,"Isolate")[[1]][1] # retrieve the label identifying the contacts matrix
  shieldLab=gsub("^_","",shieldLab) # remove starting and final "_"
  shieldLab=gsub("_$","",shieldLab)
  otherLab=stri_split_fixed(fileLabel,shieldLab)[[1]][2]
  otherLab=gsub("^_","",otherLab)
  otherLabList=unlist(stri_split_fixed(otherLab,"_"))
  outputLine=c(shieldLab,otherLabList)
  
  # ... Process Files
  i=0
  for(file2proc in files.list){
    cat("... Processing file: ", file2proc)
    i = i + 1
    fileIn = paste(file2proc, subLabel, fileLabel, ".dat", sep = "")
    # fileF = grep("^Frac", fileIn) # identify the type of file to select the statistics
    # fileN = grep("^Num", fileIn) # not used, we would compute fractions for Num files
    # fileT = grep("^Time", fileIn) # and totals for Frac files would be wrong
    df.all = read_csv(file = fileIn)
    df.all = subset(df.all, select = -c(X1))
    idx.classS = grep(keywordS, colnames(df.all)) # cols for shielded population
    idx.classE = grep(keywordE, colnames(df.all)) # remaining pop
    if (file2proc == "NumFinalDeaths") {
      # this file should be the first
      death.totals = rowSums(df.all) # because we will identify simulations with no deaths
      nodeath.obs = which(death.totals > 0) # and create an index to work only with them
    }
    df = df.all[nodeath.obs, ] # gather statistics only for cases where deaths are observed
    Nrealiz = dim(df)[1] # this will reduce the number of realizations
    df.E = df[, idx.classE] # only exposed
    df.S = df[, idx.classS] # only susceptible
    if(files.code[i] == "Frac"){
      # files for which we want to gather fractions
      stat.list = get_statistics_frac_total(df, PopSize, Nrealiz, 1)
      stat.list.E = get_statistics_frac_total(df.E, PopSize, Nrealiz, idx.classE)
      stat.list.S = get_statistics_frac_total(df.S, PopSize, Nrealiz, idx.classS)
    } else if(files.code[i] == "Num"){
      # we want total numbers
      stat.list = get_statistics_total(df, Nrealiz, 1)
      stat.list.E = get_statistics_total(df.E, Nrealiz, idx.classE)
      stat.list.S = get_statistics_total(df.S, Nrealiz, idx.classS)
    } else if(files.code[i] == "Time"){
      # we want mean peak times
      stat.list = get_statistics_peaks(df, Nrealiz, 1)
      stat.list.E = get_statistics_peaks(df.E, Nrealiz, idx.classE)
      stat.list.S = get_statistics_peaks(df.S, Nrealiz, idx.classS)
    }
    df.mean = stat.list[[1]]
    df.stdErr = stat.list[[2]]
    df.mean.E = stat.list.E[[1]]
    df.stdErr.E = stat.list.E[[2]]
    df.mean.S = stat.list.S[[1]]
    df.stdErr.S = stat.list.S[[2]]
    
    outputLine = c(outputLine, df.mean, df.stdErr)
    outputLine = c(outputLine, df.mean.E, df.stdErr.E, df.mean.S, df.stdErr.S)
    
    if (file2proc == "NumFinalDeaths") {
      # take the death totals to compute CFR
      death.totals.all = mean(rowSums(df)) 
      death.totals.E = mean(rowSums(df.E)) 
      death.totals.S = mean(rowSums(df.S)) 
      # in addition, we estimate the probability of outbreak
      frac.nodeath = apply(df, 2, function(x) {
        length(which(x == 0))
      }) / Nrealiz
      if (is_empty(idx.classS)) {
        # there is no shielding
        p.outbrk.E = signif(1 - min(frac.nodeath), digits = 2)
        p.outbrk.S = NA
      } else{
        p.outbrk.E = signif(1 - min(frac.nodeath[idx.classE]), digits = 2)
        p.outbrk.S = signif(1 - min(frac.nodeath[idx.classS]), digits = 2)
      }
      outputLine = c(outputLine, p.outbrk.E, p.outbrk.S)
    }else if (file2proc == "NumFinalRecovered") {
      recov.totals.all = mean(rowSums(df)) 
      recov.totals.E = mean(rowSums(df.E)) 
      recov.totals.S = mean(rowSums(df.S)) 
      CFR.all=signif(death.totals.all/(death.totals.all+recov.totals.all),digits=2)
      CFR.E=signif(death.totals.E/(death.totals.E+recov.totals.E),digits=2)
      CFR.S=signif(death.totals.S/(death.totals.E+recov.totals.S),digits=2)
      outputLine = c(outputLine,CFR.E,CFR.S)
    }
    
  }
  df.output[k, ] = outputLine
  setwd(dirData)
}

colnames(df.output)=header.names
setwd(dirOut)
write.table(df.output,file=fileOut,quote=FALSE,sep="\t",row.names = FALSE)
